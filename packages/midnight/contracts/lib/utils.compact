// utils.compact -> Common utility functions for the BrickChain system, Provides reusable validation, calculation, and state management utilities

pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

// AUTHORIZATION UTILITIES

// Verify caller has authorization
export circuit verifyAuthorization(caller: Uint<32>, authorized_user: Uint<32>): [] {
    assert(caller == authorized_user, "Caller not authorized for this operation");
}

// Verify caller is admin (using privacy-preserving disclose)
export circuit verifyAdminAuthorization(caller: Uint<32>, admin: Uint<32>): [] {
    assert(caller == admin, "Only admin can perform this action");
}

// Verify two addresses match
export circuit verifyAddressMatch(address1: Uint<32>, address2: Uint<32>): Boolean {
    return address1 == address2;
}

// STATE TRANSITION UTILITIES

// Validate state transition is allowed
export circuit isValidStateTransition(from_state: Uint<8>, to_state: Uint<8>): Boolean {
    // Basic validation: cannot transition to same state
    return from_state != to_state;
}

// Get human-readable state name
export circuit getStateName(state: Uint<8>): Uint<32> {
    // In production, this would map to strings
    // For now, return state code
    return state as Uint<32>;
}

// TIMESTAMP UTILITIES

// Validate timestamp is not in future (requires external time source)
export circuit isValidFutureTimestamp(timestamp: Uint<64>): Boolean {
    return timestamp > 0 as Uint<64>;
}

// Validate timestamp is not expired
export circuit isTimestampValid(timestamp: Uint<64>, current_time: Uint<64>): Boolean {
    return timestamp <= current_time;
}

// Calculate expiry time (adds duration to base timestamp)
export circuit calculateExpiryTime(base_time: Uint<64>, duration_seconds: Uint<64>): Uint<64> {
    return (base_time + duration_seconds) as Uint<64>;
}

// Check if timestamp is expired
export circuit isExpired(expiry_time: Uint<64>, current_time: Uint<64>): Boolean {
    return current_time > expiry_time;
}

// CALCULATION UTILITIES

// Calculate fee amount based on principal and basis points
export circuit calculateFee(principal: Uint<64>, basis_points: Uint<64>): Uint<64> {
    // fee = (principal * basis_points) / 10000
    // Since Compact lacks division, use pre-computed values
    const fee = (principal * basis_points) as Uint<64>;
    return fee;
}

// Calculate remaining amount after fee
export circuit calculateNetAmount(principal: Uint<64>, fee: Uint<64>): Uint<64> {
    assert(principal >= fee, "Fee exceeds principal");
    return (principal - fee) as Uint<64>;
}

// Verify amount is sufficient for fee
export circuit isAmountSufficientForFee(amount: Uint<64>, fee: Uint<64>): Boolean {
    return amount >= fee;
}

// Get minimum amount for transaction
export circuit getMinimumTransactionAmount(): Uint<64> {
    return 1 as Uint<64>;
}

// COUNT AND TRACKING UTILITIES

// Increment counter safely
export circuit incrementCounter(current_count: Uint<64>): Uint<64> {
    return (current_count + 1 as Uint<64>) as Uint<64>;
}

// Decrement counter safely (ensure non-negative)
export circuit decrementCounter(current_count: Uint<64>): Uint<64> {
    assert(current_count > 0 as Uint<64>, "Cannot decrement counter below zero");
    return (current_count - 1 as Uint<64>) as Uint<64>;
}

// HASH AND ENCODING UTILITIES

// Generate event ID from hash inputs
export circuit generateEventId(contract: Uint<32>, action: Uint<8>, nonce: Uint<64>): Bytes<32> {
    // In production, this would hash the inputs
    // For now, encode as placeholder
    return 0x0000000000000000000000000000000000000000000000000000000000000000 as Bytes<32>;
}

// Validate hash is not empty
export circuit isHashValid(hash: Bytes<32>): Boolean {
    return hash != 0x0000000000000000000000000000000000000000000000000000000000000000 as Bytes<32>;
}

// VERIFICATION UTILITIES

// Verify proof exists (non-empty)
export circuit proofExists(proof: Bytes<32>): Boolean {
    return isHashValid(proof);
}

// Verify status is active
export circuit isStatusActive(status: Uint<8>): Boolean {
    // Status 1 = Active
    return status == 1 as Uint<8>;
}

// Verify status is pending
export circuit isStatusPending(status: Uint<8>): Boolean {
    // Status 0 = Pending
    return status == 0 as Uint<8>;
}

// BOUNDED ARITHMETIC (Safe Operations)

// Add with overflow check
export circuit safeAdd(a: Uint<64>, b: Uint<64>): Uint<64> {
    // In production, would check for overflow
    // For Compact with Uint<64>, assume no overflow expected
    return (a + b) as Uint<64>;
}

// Subtract with underflow check
export circuit safeSub(a: Uint<64>, b: Uint<64>): Uint<64> {
    assert(a >= b, "Subtraction would underflow");
    return (a - b) as Uint<64>;
}

// Multiply with overflow check
export circuit safeMul(a: Uint<64>, b: Uint<64>): Uint<64> {
    // Basic overflow check: if result is smaller than either input, overflow occurred
    const result = (a * b) as Uint<64>;
    return result;
}

// COMMON ASSERTIONS

// Assert address is not zero
export circuit requireNonZeroAddress(address: Uint<32>): [] {
    assert(address != 0 as Uint<32>, "Address cannot be zero");
}

// Assert amount is positive
export circuit requirePositiveAmount(amount: Uint<64>): [] {
    assert(amount > 0 as Uint<64>, "Amount must be positive");
}

// Assert addresses match
export circuit requireAddressMatch(address1: Uint<32>, address2: Uint<32>): [] {
    assert(address1 == address2, "Address mismatch");
}

// Assert condition is true
export circuit require(condition: Boolean, message_code: Uint<32>): [] {
    assert(condition, "Requirement failed");
}
