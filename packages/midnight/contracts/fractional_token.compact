pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;
import "./lib/types.compact";

export ledger {
  totalShares: Map<u64, u64>;
  balances: Map<(u64, Address), u64>;
  ownershipProofs: Map<(u64, Address), OwnershipProof>;
  transferHistory: Map<u64, u64>; // pid -> transfer count
  isPaused: Map<u64, bool>;
  adminAddress: Address = zero_address;
  transferFee: u128 = 1000u128; // Base transfer fee
}

export circuit initializeToken(admin: Address): [] {
  require(adminAddress == zero_address, "Already initialized");
  adminAddress = admin;
  publish("TOKEN_INITIALIZED", admin);
}

export circuit initializeShares(
  pid: u64, 
  owner: Address, 
  total: u64,
  authProof: Opaque<"bool">
): [] {
  require(total > 0u64, "Invalid total");
  require(total <= 1000000u64, "Total shares too high");
  require(totalShares[pid] == 0u64, "Already initialized");

  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");

  totalShares[pid] = total;
  balances[(pid, owner)] = total;
  transferHistory[pid] = 0u64;
  isPaused[pid] = false;

  // Generate initial ownership proof
  let proof: OwnershipProof = {
    owner: owner,
    pid: pid,
    shareAmount: total,
    proofHash: "initial_proof",
    generatedAt: 0u64 //current timestamp
  };
  ownershipProofs[(pid, owner)] = proof;

  publish("SHARES_INITIALIZED", pid, owner, total);
}

export circuit transferShares(
  pid: u64,
  from: Address,
  to: Address,
  amount: u64,
  authProof: Opaque<"bool">
): [] {
  require(!isPaused[pid], "Transfers paused for this property");
  require(amount > 0u64, "Invalid amount");
  require(from != to, "Cannot transfer to self");

  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");

  let senderBal = balances[(pid, from)];
  require(senderBal >= amount, "Insufficient shares");

  // Update balances
  balances[(pid, from)] = senderBal - amount;
  balances[(pid, to)] = balances[(pid, to)] + amount;

  // Update transfer history
  transferHistory[pid] = transferHistory[pid] + 1u64;

  // Update ownership proofs
  let fromProof: OwnershipProof = {
    owner: from,
    pid: pid,
    shareAmount: senderBal - amount,
    proofHash: "updated_proof_from",
    generatedAt: 0u64
  };
  ownershipProofs[(pid, from)] = fromProof;

  let toProof: OwnershipProof = {
    owner: to,
    pid: pid,
    shareAmount: balances[(pid, to)],
    proofHash: "updated_proof_to",
    generatedAt: 0u64
  };
  ownershipProofs[(pid, to)] = toProof;

  publish("SHARES_TRANSFERRED", pid, from, to, amount);
}

export circuit burnShares(
  pid: u64,
  owner: Address,
  amount: u64,
  authProof: Opaque<"bool">
): [] {
  require(amount > 0u64, "Invalid amount");

  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");

  let ownerBal = balances[(pid, owner)];
  require(ownerBal >= amount, "Insufficient shares");

  balances[(pid, owner)] = ownerBal - amount;
  totalShares[pid] = totalShares[pid] - amount;

  // Update ownership proof
  let proof: OwnershipProof = {
    owner: owner,
    pid: pid,
    shareAmount: ownerBal - amount,
    proofHash: "burned_proof",
    generatedAt: 0u64
  };
  ownershipProofs[(pid, owner)] = proof;

  publish("SHARES_BURNED", pid, owner, amount);
}

export circuit pauseTransfers(
  pid: u64,
  authProof: Opaque<"bool">
): [] {
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Admin only");

  isPaused[pid] = true;
  publish("TRANSFERS_PAUSED", pid);
}

export circuit unpauseTransfers(
  pid: u64,
  authProof: Opaque<"bool">
): [] {
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Admin only");

  isPaused[pid] = false;
  publish("TRANSFERS_UNPAUSED", pid);
}

export circuit generateOwnershipProof(
  pid: u64,
  owner: Address,
  proofHash: string,
  authProof: Opaque<"bool">
): [] {
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");

  let balance = balances[(pid, owner)];
  require(balance > 0u64, "No shares owned");

  let proof: OwnershipProof = {
    owner: owner,
    pid: pid,
    shareAmount: balance,
    proofHash: proofHash,
    generatedAt: 0u64 //current timestamp
  };
  ownershipProofs[(pid, owner)] = proof;

  publish("OWNERSHIP_PROOF_GENERATED", pid, owner, proofHash);
}
