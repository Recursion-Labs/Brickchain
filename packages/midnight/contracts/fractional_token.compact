pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

import "./lib/types.compact";
import "./utils.compact";

export ledger {
  totalShares: Map<u64, u64>;
  balances: Map<(u64, Address), u64>;
  ownershipProofs: Map<(u64, Address), OwnershipProof>;
  transferHistory: Map<u64, u64>;
  isPaused: Map<u64, bool>;
  adminAddress: Address = zero_address;
  transferFee: u128 = 1000u128; // Base transfer fee
}

export circuit initializeToken(admin: Address): [] {
  require(adminAddress == zero_address, "Already initialized");
  adminAddress = admin;
  publish("TOKEN_INITIALIZED", admin);
}

export circuit initializeShares(
  pid: u64,
  owner: Address,
  total: u64,
  authProof: Opaque<"bool">
): [] {
  require(total > 0u64, "Invalid total");
  require(total <= 1000000u64, "Total shares too high");
  require(totalShares[pid] == 0u64, "Already initialized");
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");
  totalShares[pid] = total;
  balances[(pid, owner)] = total;
  transferHistory[pid] = 0u64;
  isPaused[pid] = false;
  publish("SHARES_INITIALIZED", pid, owner, total);
}

export circuit transferShares(
  pid: u64,
  from: Address,
  to: Address,
  amount: u64,
  authProof: Opaque<"bool">
): [] {
  require(!isPaused[pid], "Token is paused");
  require(balances[(pid, from)] >= amount, "Insufficient balance");
  require(from != to, "Cannot transfer to self");
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");
  balances[(pid, from)] -= amount;
  balances[(pid, to)] += amount;
  transferHistory[pid] += 1u64;
  ownershipProofs[(pid, to)] = generateOwnershipProof(pid, to);
  publish("SHARES_TRANSFERRED", pid, from, to, amount);
}

// Utility function: stub for ownership proof generation
export circuit generateOwnershipProof(
  pid: u64,
  owner: Address
): OwnershipProof {
  // For production, implement ZK proof generation
  let proof: OwnershipProof = {
    pid: pid,
    owner: owner,
    proofHash: "PLACEHOLDER_HASH"
  };
  return proof;
}

export circuit mintShares(
  pid: u64,
  to: Address,
  amount: u64,
  authProof: Opaque<"bool">
): [] {
  require(!isPaused[pid], "Token is paused");
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");
  totalShares[pid] += amount;
  balances[(pid, to)] += amount;
  publish("SHARES_MINTED", pid, to, amount);
}

export circuit burnShares(
  pid: u64,
  from: Address,
  amount: u64,
  authProof: Opaque<"bool">
): [] {
  require(!isPaused[pid], "Token is paused");
  require(balances[(pid, from)] >= amount, "Insufficient balance");
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Unauthorized");
  balances[(pid, from)] -= amount;
  totalShares[pid] -= amount;
  publish("SHARES_BURNED", pid, from, amount);
}

export circuit pauseToken(pid: u64, authProof: Opaque<"bool">): [] {
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Admin only");
  isPaused[pid] = true;
  publish("TOKEN_PAUSED", pid);
}

export circuit unpauseToken(pid: u64, authProof: Opaque<"bool">): [] {
  let auth = disclose(authProof);
  require(auth == "true" || auth == "1", "Admin only");
  isPaused[pid] = false;
  publish("TOKEN_UNPAUSED", pid);
}
