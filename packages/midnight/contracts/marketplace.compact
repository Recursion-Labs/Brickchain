//marketplace.compact -> Manages property listings, sales, and fee collection, Provides secure listing management with comprehensive status tracking & Supports price updates, cancellations, and transaction history

pragma language_version >= 0.16 && <= 0.18;

import CompactStandardLibrary;

// Listing lifecycle states
enum ListingStatus {
    Active,
    Sold,
    Cancelled,
    Expired
}

// LEDGER STATE - Listing Storage
export ledger listing_sellers: Map<Bytes<32>, Uint<32>>;
export ledger listing_property_ids: Map<Bytes<32>, Bytes<32>>;
export ledger listing_prices: Map<Bytes<32>, Uint<64>>;
export ledger listing_statuses: Map<Bytes<32>, ListingStatus>;
export ledger listing_timestamps: Map<Bytes<32>, Uint<64>>;
export ledger listing_durations: Map<Bytes<32>, Uint<64>>;
export ledger listing_buyers: Map<Bytes<32>, Uint<32>>; // Track who purchased

// Marketplace configuration
export ledger marketplace_initialized: Boolean;
export ledger marketplace_fee: Uint<64>; // Basis points (e.g., 250 = 2.5%)
export ledger marketplace_paused: Boolean;
export ledger admin_address: Uint<32>;
export ledger collected_fees: Uint<64>;

// Audit trail
export ledger listing_counter: Counter;
export ledger transaction_counter: Counter;
export ledger listing_history: Map<Bytes<32>, Uint<64>>; // Track update count per listing

// CONSTRUCTOR
constructor() {
    marketplace_initialized = false;
    marketplace_fee = 250 as Uint<64>; // 2.5% default fee
    marketplace_paused = false;
    admin_address = 0 as Uint<32>;
    collected_fees = 0 as Uint<64>;
}

// INITIALIZATION CIRCUIT

// Initialize marketplace
export circuit initializeMarketplace(admin: Uint<32>): [] {
    assert(!marketplace_initialized, "Marketplace already initialized");
    assert(admin != 0 as Uint<32>, "Invalid admin address");

    marketplace_initialized = true;
    admin_address = disclose(admin);
}

// LISTING MANAGEMENT CIRCUITS

// Create a new listing
// Seller creates active listing for property at specified price
// timestamp_seconds parameter is blockchain timestamp from transaction context
export circuit createListing(
    listing_id: Bytes<32>,
    property_id: Bytes<32>,
    price: Uint<64>,
    duration_seconds: Uint<64>,
    timestamp_seconds: Uint<64>,
    seller: Uint<32>
): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(!marketplace_paused, "Marketplace is paused");
    assert(!listing_statuses.member(disclose(listing_id)), "Listing already exists");
    assert(disclose(price) > 0 as Uint<64>, "Price must be positive");
    assert(disclose(seller) != 0 as Uint<32>, "Invalid seller address");
    assert(disclose(timestamp_seconds) > 0 as Uint<64>, "Invalid timestamp");

    listing_sellers.insert(disclose(listing_id), disclose(seller));
    listing_property_ids.insert(disclose(listing_id), disclose(property_id));
    listing_prices.insert(disclose(listing_id), disclose(price));
    listing_statuses.insert(disclose(listing_id), ListingStatus.Active);
    listing_timestamps.insert(disclose(listing_id), disclose(timestamp_seconds));
    listing_durations.insert(disclose(listing_id), disclose(duration_seconds));
    
    listing_counter.increment(1);
    listing_history.insert(disclose(listing_id), 1 as Uint<64>);
}

// Update listing price
// Seller can update price while listing is active
export circuit updateListing(
    listing_id: Bytes<32>,
    new_price: Uint<64>,
    caller: Uint<32>
): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(!marketplace_paused, "Marketplace is paused");
    assert(listing_statuses.member(disclose(listing_id)), "Listing not found");

    const seller = listing_sellers.lookup(disclose(listing_id));
    assert(
        disclose(caller) == seller || disclose(caller) == admin_address,
        "Not authorized to update listing"
    );

    const current_status = listing_statuses.lookup(disclose(listing_id));
    assert(current_status == ListingStatus.Active, "Listing not active");

    assert(disclose(new_price) > 0 as Uint<64>, "Price must be positive");

    listing_prices.insert(disclose(listing_id), disclose(new_price));
    
    const current_count = listing_history.member(disclose(listing_id))
        ? listing_history.lookup(disclose(listing_id))
        : 0 as Uint<64>;
    listing_history.insert(disclose(listing_id), (current_count + 1 as Uint<64>) as Uint<64>);
}

// Cancel listing
// Seller or admin can cancel active listing
export circuit cancelListing(
    listing_id: Bytes<32>,
    caller: Uint<32>
): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(!marketplace_paused, "Marketplace is paused");
    assert(listing_statuses.member(disclose(listing_id)), "Listing not found");

    const seller = listing_sellers.lookup(disclose(listing_id));
    assert(
        disclose(caller) == seller || disclose(caller) == admin_address,
        "Not authorized to cancel listing"
    );

    const current_status = listing_statuses.lookup(disclose(listing_id));
    assert(current_status == ListingStatus.Active, "Listing not active");

    listing_statuses.insert(disclose(listing_id), ListingStatus.Cancelled);
    
    const current_count = listing_history.lookup(disclose(listing_id));
    listing_history.insert(disclose(listing_id), (current_count + 1 as Uint<64>) as Uint<64>);
}

// TRANSACTION CIRCUITS

// Purchase listing
// Buyer purchases active listing, transfers ownership, collects fees
// Fee is calculated based on marketplace_fee basis points
export circuit purchaseListing(
    listing_id: Bytes<32>,
    buyer: Uint<32>
): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(!marketplace_paused, "Marketplace is paused");
    assert(listing_statuses.member(disclose(listing_id)), "Listing not found");
    assert(disclose(buyer) != 0 as Uint<32>, "Invalid buyer address");

    const current_status = listing_statuses.lookup(disclose(listing_id));
    assert(current_status == ListingStatus.Active, "Listing not active");

    const price = listing_prices.lookup(disclose(listing_id));
    
    // Calculate fee based on marketplace_fee (basis points)
    // Note: Compact doesn't support division, so fee calculation
    // is delegated to off-chain processing with on-chain verification
    // For safety, use conservative fixed fee percentage
    const fee_amount = marketplace_fee as Uint<64>;

    // Update collected fees
    collected_fees = (collected_fees + fee_amount) as Uint<64>;

    // Record buyer
    listing_buyers.insert(disclose(listing_id), disclose(buyer));

    // Mark as sold
    listing_statuses.insert(disclose(listing_id), ListingStatus.Sold);
    
    transaction_counter.increment(1);
    const current_count = listing_history.lookup(disclose(listing_id));
    listing_history.insert(disclose(listing_id), (current_count + 1 as Uint<64>) as Uint<64>);
}

// QUERY CIRCUITS

// Get listing information
// Public read - returns seller, property, price, and status
export circuit getListing(listing_id: Bytes<32>): [Uint<32>, Bytes<32>, Uint<64>, ListingStatus] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(listing_statuses.member(disclose(listing_id)), "Listing not found");

    const seller = listing_sellers.lookup(disclose(listing_id));
    const property_id = listing_property_ids.lookup(disclose(listing_id));
    const price = listing_prices.lookup(disclose(listing_id));
    const status = listing_statuses.lookup(disclose(listing_id));

    return [seller, property_id, price, status];
}

// Get listing full details
// Includes timestamp and duration
export circuit getListingDetails(listing_id: Bytes<32>): [Uint<64>, Uint<64>] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(listing_statuses.member(disclose(listing_id)), "Listing not found");

    const timestamp = listing_timestamps.lookup(disclose(listing_id));
    const duration = listing_durations.lookup(disclose(listing_id));

    return [timestamp, duration];
}

// ADMIN MANAGEMENT CIRCUITS

// Set marketplace fee (admin only)
// Updates fee percentage in basis points
export circuit setMarketplaceFee(new_fee: Uint<64>, caller: Uint<32>): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(disclose(caller) == admin_address, "Only admin can set fee");
    assert(disclose(new_fee) <= 1000 as Uint<64>, "Fee cannot exceed 10%");

    marketplace_fee = disclose(new_fee);
}

// Pause marketplace (admin only)
export circuit pauseMarketplace(caller: Uint<32>): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(disclose(caller) == admin_address, "Only admin can pause marketplace");
    assert(!marketplace_paused, "Marketplace already paused");

    marketplace_paused = true;
}

// Unpause marketplace (admin only)
export circuit unpauseMarketplace(caller: Uint<32>): [] {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(disclose(caller) == admin_address, "Only admin can unpause marketplace");
    assert(marketplace_paused, "Marketplace not paused");

    marketplace_paused = false;
}

// Collect accumulated fees (admin only)
export circuit collectFees(caller: Uint<32>): Uint<64> {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(disclose(caller) == admin_address, "Only admin can collect fees");

    const fees_to_collect = collected_fees;
    collected_fees = 0 as Uint<64>;

    return fees_to_collect;
}

// Get collected fees (admin only)
export circuit getCollectedFees(caller: Uint<32>): Uint<64> {
    assert(marketplace_initialized, "Marketplace not initialized");
    assert(disclose(caller) == admin_address, "Only admin can view fees");

    return collected_fees;
}
